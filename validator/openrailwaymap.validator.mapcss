meta
{
	title: "OpenRailwayMap";
	version: "2014-10-06";
	description: "Validation of railway data according to the OpenRailwayMap tagging scheme.";
	author: "rurseekatze";
	link: "https://wiki.openstreetmap.org/wiki/OpenRailwayMap/Tagging";
	watch-modified: true;
}

/* Track with usage AND service */
way[railway][usage][service]
{
	throwError: "Track tagged with usage=* AND service=* - remove one of these tags";
	fixRemove: "service";
	assertMatch: "way railway=rail usage=main service=siding";
	assertNoMatch: "way railway=rail usage=main";
	assertNoMatch: "way railway=rail service=siding";
}

/* Station mapped as way or area */
way[railway=station], area[railway=station]
{
	throwError: "Station mapped as a way, but should be mapped as a node";
	assertMatch: "way railway=station";
	assertMatch: "area railway=station";
	assertNoMatch: "node railway=station";
}

/* Milestone without position */
node[railway=milestone][!railway:position]
{
	throwWarning: "Milestone without position, add railway:position=*";
	assertMatch: "node railway=milestone";
	assertNoMatch: "node railway=milestone railway:position=42.0";
}

/* Track without operator */
way[railway][!operator]
{
	throwOther: "Track without with operator";
	assertMatch: "way railway=rail";
	assertNoMatch: "node railway=rail operator=SNCF";
	assertNoMatch: "area railway=rail";
	assertNoMatch: "way railway=rail operator=SNCF";
}

/* traffic_mode is deprecated, should be changed to railway:traffic_mode */
way[railway][traffic_mode]
{
	throwError: "Key traffic_mode is deprecated, change to railway:traffic_mode";
	fixChangeKey: "traffic_mode=>railway:traffic_mode";
	assertMatch: "way railway=rail traffic_mode=passenger";
	assertNoMatch: "node railway=rail";
	assertNoMatch: "way railway=rail";
	assertNoMatch: "area railway=rail";
	assertNoMatch: "way railway=rail railway:traffic_mode=passenger";
}

/* Track without workrules */
way[railway][!workrules]
{
	throwOther: "Track without with workrules";
	assertMatch: "way railway=rail";
	assertNoMatch: "node railway=rail workrules=EBO";
	assertNoMatch: "area railway=rail";
	assertNoMatch: "way railway=rail workrules=EBO";
}

/* workrules=EBO is deprecated, should be changed to workrules=DE:EBO */
/* workrules=ESBO is deprecated, should be changed to workrules=DE:ESBO */
/* workrules=BOStrab is deprecated, should be changed to workrules=DE:BOStrab */
way[railway][workrules=EBO],
way[railway][workrules=ESBO],
way[railway][workrules=BOStrab]
{
	throwError: "workrules={1.value} is deprecated, change to workrules=DE:{1.value}";
	assertMatch: "way railway=rail workrules=EBO";
	assertMatch: "way railway=rail workrules=ESBO";
	assertMatch: "way railway=rail workrules=BOStrab";
	assertNoMatch: "node railway=rail";
	assertNoMatch: "way railway=rail";
	assertNoMatch: "area railway=rail";
	assertNoMatch: "way railway=rail workrules=DE:EBO";
	assertNoMatch: "way railway=rail workrules=DE:ESBO";
	assertNoMatch: "way railway=rail workrules=DE:BOStrab";
	fixAdd: "workrules=DE:{1.value}";
}

/* workrules=BOA is deprecated, should be replaced by an adequate value */
way[railway][workrules=BOA]
{
	throwError: "workrules=BOA is deprecated, replace by an adequate value";
	assertMatch: "way railway=rail workrules=BOA";
	assertNoMatch: "node railway=rail";
	assertNoMatch: "way railway=rail";
	assertNoMatch: "area railway=rail";
	assertNoMatch: "way railway=rail workrules=DE:BOStrab";
}

/* operator is not necessary for signals and milestones if equal to track operator */
node[railway=signal][operator],
node[railway=milestone][operator]
{
	throwWarning: "operator is not necessary for {0.value}s if equal to track operator";
	assertMatch: "node railway=signal operator=DB";
	assertMatch: "node railway=milestone operator=DB";
	assertNoMatch: "node railway=signal";
	assertNoMatch: "way railway=rail operator=DB";
	assertNoMatch: "node railway=milestone";
	assertNoMatch: "way railway=rail operator=DB";
	fixRemove: "operator";
}

/* supervised=* is deprecated, replace it with the new crossing:supervision=* */
node[railway=level_crossing][supervised], node[railway=crossing][supervised]
{
	throwWarning: "supervised=* is deprecated, replace it with the new crossing:supervision=*";
	assertMatch: "node railway=level_crossing supervised=yes";
	assertNoMatch: "node railway=level_crossing";
	fixChangeKey: "supervised=>crossing:supervision";
}

/* signal specification given but node is not tagged as signal or equivalent type */
node[/^railway:signal:/][railway!=signal][railway!=buffer_stop][railway!=derail]
{
	throwWarning: "signal specification given but node is not tagged as signal or equivalent type";
	assertMatch: "node railway:signal:direction=forward";
	assertMatch: "node railway:signal:position=right railway=level_crossing";
	assertNoMatch: "node railway:signal:position=right railway=signal";
	assertNoMatch: "node railway=signal railway:signal:direction=forward";
	assertNoMatch: "node railway=buffer_stop railway:signal:minor=sh2";
	assertNoMatch: "node railway=derail railway:signal:minor=sh";
}

/* ks and hl signals only exist as light signals */
node[railway=signal][railway:signal:main=ks][railway:signal:main:form!=light],
node[railway=signal][railway:signal:distant=ks][railway:signal:distant:form!=light],
node[railway=signal][railway:signal:combined=ks][railway:signal:combined:form!=light],
node[railway=signal][railway:signal:main="DE-ESO:ks"][railway:signal:main:form!=light],
node[railway=signal][railway:signal:distant="DE-ESO:ks"][railway:signal:distant:form!=light],
node[railway=signal][railway:signal:combined="DE-ESO:ks"][railway:signal:combined:form!=light],
node[railway=signal][railway:signal:main=hl][railway:signal:main:form!=light],
node[railway=signal][railway:signal:distant=hl][railway:signal:distant:form!=light],
node[railway=signal][railway:signal:combined=hl][railway:signal:combined:form!=light],
node[railway=signal][railway:signal:main="DE-ESO:hl"][railway:signal:main:form!=light],
node[railway=signal][railway:signal:distant="DE-ESO:hl"][railway:signal:distant:form!=light],
node[railway=signal][railway:signal:combined="DE-ESO:hl"][railway:signal:combined:form!=light]
{
	throwError: "{1.value} signals only exist as light signals";
	assertMatch: "node railway=signal railway:signal:main=ks";
	assertMatch: "node railway=signal railway:signal:main=ks railway:signal:main:form=semaphore";
	assertMatch: "node railway=signal railway:signal:main=hl";
	assertMatch: "node railway=signal railway:signal:main=hl railway:signal:main:form=semaphore";
	assertNoMatch: "node railway=signal railway:signal:main=hl railway:signal:main:form=light";
	assertNoMatch: "node railway=signal railway:signal:main=ks railway:signal:main:form=light";
	fixAdd: "{2.key}=light";
}

/* hp signals only exist as semaphore or light signals */
node[railway=signal][railway:signal:main=hp][railway:signal:main:form!=light][railway:signal:main:form!=semaphore],
node[railway=signal][railway:signal:distant=vr][railway:signal:distant:form!=light][railway:signal:distant:form!=semaphore],
node[railway=signal][railway:signal:main="DE-ESO:hp"][railway:signal:main:form!=light][railway:signal:main:form!=semaphore],
node[railway=signal][railway:signal:distant="DE-ESO:vr"][railway:signal:distant:form!=light][railway:signal:distant:form!=semaphore]
{
	throwError: "hp signals only exist as semaphore or light signals";
	assertMatch: "node railway=signal railway:signal:main=hp";
	assertMatch: "node railway=signal railway:signal:main=hp railway:signal:main:form=typo";
	assertNoMatch: "node railway=signal railway:signal:main=hp railway:signal:main:form=semaphore";
	assertNoMatch: "node railway=signal railway:signal:main=hp railway:signal:main:form=light";
}

/* KVB combined hp signals only exist as light signals */
node[railway=signal][railway:signal:combined=hp][railway:signal:combined:form!=light],
node[railway=signal][railway:signal:combined="DE-KVB:hp"][railway:signal:combined:form!=light]
{
	throwError: "KVB hp signals only exist as light signals";
	assertMatch: "node railway=signal railway:signal:combined=hp";
	assertMatch: "node railway=signal railway:signal:combined=DE-KVB:hp railway:signal:combined:form=typo";
	assertMatch: "node railway=signal railway:signal:combined=hp railway:signal:combined:form=semaphore";
	assertNoMatch: "node railway=signal railway:signal:combined=hp railway:signal:combined:form=light";
	assertNoMatch: "node railway=signal railway:signal:combined=DE-KVB:hp railway:signal:combined:form=light";
}

/* a signal which is a sign cannot have different states */
node|z14-[railway=signal]["railway:signal:main:form"=sign]["railway:signal:main:states"],
node|z14-[railway=signal]["railway:signal:distant:form"=sign]["railway:signal:distant:states"],
node|z14-[railway=signal]["railway:signal:combined:form"=sign]["railway:signal:combined:states"],
node|z14-[railway=signal]["railway:signal:shunting:form"=sign]["railway:signal:shunting:states"],
node|z14-[railway=signal]["railway:signal:main_repeated:form"=sign]["railway:signal:main_repeated:states"],
node|z14-[railway=signal]["railway:signal:minor:form"=sign]["railway:signal:minor:states"],
node|z14-[railway=signal]["railway:signal:minor_distant:form"=sign]["railway:signal:minor_distant:states"],
node|z14-[railway=signal]["railway:signal:crossing:form"=sign]["railway:signal:crossing:states"],
node|z14-[railway=signal]["railway:signal:crossing_distant:form"=sign]["railway:signal:crossing_distant:states"],
node|z14-[railway=signal]["railway:signal:humping:form"=sign]["railway:signal:humping:states"],
node|z14-[railway=signal]["railway:signal:speed_limit:form"=sign]["railway:signal:speed_limit:states"],
node|z14-[railway=signal]["railway:signal:speed_limit_distant:form"=sign]["railway:signal:speed_limit_distant:states"],
node|z14-[railway=signal]["railway:signal:route:form"=sign]["railway:signal:route:states"],
node|z14-[railway=signal]["railway:signal:route_distant:form"=sign]["railway:signal:route_distant:states"],
node|z14-[railway=signal]["railway:signal:wrong_road:form"=sign]["railway:signal:wrong_road:states"],
node|z14-[railway=signal]["railway:signal:stop_demand:form"=sign]["railway:signal:stop_demand:states"],
node|z14-[railway=signal]["railway:signal:departure:form"=sign]["railway:signal:departure:states"],
node|z14-[railway=signal]["railway:signal:resetting_switch:form"=sign]["railway:signal:resetting_switch:states"],
node|z14-[railway=signal]["railway:signal:short_route:form"=sign]["railway:signal:short_route:states"],
node|z14-[railway=signal]["railway:signal:brake_test:form"=sign]["railway:signal:brake_test:states"]
{
	throwError: "A sign cannot have different states.";
	assertMatch: "way railway=signal railway:signal:main:states=hp0;hp1 railway:signal:main:form=sign";
	assertNoMatch: "way railway=signal railway:signal:main:states=hp0;hp1 railway:signal:main:form=semaphore";
	assertNoMatch: "way railway=signal railway:signal:main:states=hp0;hp1 railway:signal:main:form=light";
}

/* track numbers inside a station should be railway:track_ref, not name */
way[railway][name=~/^[0-9]+[a-z]*.*/]
{
	throwError: "track numbers inside a station should be railway:track_ref, not name";
	assertMatch: "way railway=rail name=4";
	assertMatch: "way railway=rail name=4a";
	assertMatch: "way railway=light_rail name=14";
	assertMatch: "way railway=rail name=14b";
	assertNoMatch: "way railway=rail name=\"Gleis 14b\"";
	assertNoMatch: "way railway=rail name=\"track 4b\"";
	fixChangeKey: "name=>railway:track_ref";
}

/* track numbers inside a station should be railway:track_ref, not name */
way[railway][name=~/^Gleis [0-9]+[a-z]*.*/],
way[railway][name=~/^track [0-9]+[a-z]*.*/],
way[railway][ref=~/^Gleis [0-9]+[a-z]*.*/],
way[railway][ref=~/^track [0-9]+[a-z]*.*/]
{
	throwError: "track names or ref should not include the word 'track'";
	assertMatch: "way railway=rail name=\"Gleis 14b\"";
	assertMatch: "way railway=rail ref=\"track 4b\"";
	assertNoMatch: "way railway=rail name=14b";
}

/* power:type=overhead is deprecated, change to electrified=contact_line */
way[railway]["power:type"=overhead][electrified=contact_line],
way[railway]["power:type"=overhead][electrified=yes],
way[railway]["power:type"=overhead][!electrified]
{
	throwError: "power:type=overhead is deprecated, change to electrified=contact_line";
	assertMatch: "way railway=rail power:type=overhead";
	assertMatch: "way railway=rail power:type=overhead electrified=yes";
	assertNoMatch: "way railway=rail power:type=overhead electrified=something";
	fixRemove: "power:type";
	fixAdd: "electrified=contact_line";
}

/* power:type=overhead is deprecated, change to electrified=contact_line */
way[railway]["power:type"=overhead][electrified!=yes][electrified!=contact_line]
{
	throwError: "power:type=overhead is deprecated, change to electrified=contact_line";
	assertMatch: "way railway=rail power:type=overhead";
	assertNoMatch: "way railway=rail power:type=overhead electrified=yes";
}

/* power:type=overhead is deprecated, change to electrified=contact_line */
way[railway]["power:type"]["power:type"!=overhead]
{
	throwError: "power:type is deprecated, change to proper electrified value";
	assertMatch: "way railway=rail power:type=something";
	assertNoMatch: "way railway=rail power:type=overhead electrified=yes";
}

/* priority on railway lines is deprecated, remove if usage or service is tagged */
way[railway][priority][service],
way[railway][priority][usage],
way[railway=tram][priority],
way[railway=subway][priority],
way[railway="light_rail"][priority]
{
	throwError: "priority on railway lines is deprecated, remove if usage or service is tagged";
	assertMatch: "way railway=rail priority=primary service=siding";
	assertMatch: "way railway=rail priority=primary usage=main";
	assertNoMatch: "way railway=rail priority=primary";
	fixRemove: "priority";
}

/* priority on railway lines is deprecated, add proper usage or service tags */
way[railway][railway!=subway][railway!=tram][railway!="light_rail"][priority][!service][!usage]
{
	throwError: "priority on railway lines is deprecated, add proper usage or service tags";
	assertMatch: "way railway=rail priority=primary";
	assertNoMatch: "way railway=rail priority=primary service=siding";
	assertNoMatch: "way railway=rail priority=primary usage=main";
}

/* tracks with tracks=1 and detail=track */
way[railway][tracks=1][detail=track]
{
	throwWarning: "tracks=1 not necessary if detail=track is tagged.";
	assertMatch: "way railway=rail tracks=1 detail=track";
	assertNoMatch: "way railway=rail tracks=2 detail=track";
	assertNoMatch: "way railway=rail tracks=1 detail!=track";
	fixRemove: "tracks";
}

/* tracks with tracks>1 and service=* */
way[railway][tracks!=1][tracks][service]
{
	throwWarning: "If tracks are tagged with service=*, they should be mapped as one way per track.";
	assertMatch: "way railway=rail tracks=2 service";
	assertNoMatch: "way railway=rail tracks=2 usage";
	assertNoMatch: "way railway=rail tracks=1";
}

/* crossings and level crossings should be mapped as nodes */
way[railway=crossing],
way[railway=level_crossing],
area[railway=crossing],
area[railway=level_crossing]
{
	throwError: "Crossings and level crossings should be mapped as nodes";
	assertMatch: "way railway=level_crossing railway:position:exact";
	assertMatch: "area railway=crossing railway:position:exact";
	assertNoMatch: "node railway=level_crossing";
}
