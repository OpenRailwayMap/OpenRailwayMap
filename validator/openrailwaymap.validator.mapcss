meta
{
	title: "OpenRailwayMap";
	version: "2014-10-06";
	description: "Validation of railway data according to the OpenRailwayMap tagging scheme.";
	author: "rurseekatze";
	link: "https://wiki.openstreetmap.org/wiki/OpenRailwayMap/Tagging";
	watch-modified: true;
}

/* Track with usage AND service */
way[railway][usage][service]
{
	throwError: "Track tagged with usage=* AND service=* - remove one of these tags";
	fixRemove: "service";
	assertMatch: "way railway=rail usage=main service=siding";
	assertNoMatch: "way railway=rail usage=main";
	assertNoMatch: "way railway=rail service=siding";
}

/* Station mapped as way or area */
way[railway=station], area[railway=station]
{
	throwError: "Station mapped as a way, but should be mapped as a node";
	assertMatch: "way railway=station";
	assertMatch: "area railway=station";
	assertNoMatch: "node railway=station";
}

/* Milestone without position */
node[railway=milestone][!railway:position]
{
	throwWarning: "Milestone without position, add railway:position=*";
	assertMatch: "node railway=milestone";
	assertNoMatch: "node railway=milestone railway:position=42.0";
}

/* Track without operator */
way[railway][!operator]
{
	throwOther: "Track without with operator";
	assertMatch: "way railway=rail";
	assertNoMatch: "node railway=rail operator=SNCF";
	assertNoMatch: "area railway=rail";
	assertNoMatch: "way railway=rail operator=SNCF";
}

/* traffic_mode is deprecated, should be changed to railway:traffic_mode */
way[railway][traffic_mode]
{
	throwError: "Key traffic_mode is deprecated, change to railway:traffic_mode";
	fixChangeKey: "traffic_mode=>railway:traffic_mode";
	assertMatch: "way railway=rail traffic_mode=passenger";
	assertNoMatch: "node railway=rail";
	assertNoMatch: "way railway=rail";
	assertNoMatch: "area railway=rail";
	assertNoMatch: "way railway=rail railway:traffic_mode=passenger";
}

/* Track without workrules */
way[railway][!workrules]
{
	throwOther: "Track without with workrules";
	assertMatch: "way railway=rail";
	assertNoMatch: "node railway=rail workrules=EBO";
	assertNoMatch: "area railway=rail";
	assertNoMatch: "way railway=rail workrules=EBO";
}

/* workrules=EBO is deprecated, should be changed to workrules=DE:EBO */
way[railway][workrules=EBO]
{
	throwError: "workrules=EBO is deprecated, change to workrules=DE:EBO";
	assertMatch: "way railway=rail workrules=EBO";
	assertNoMatch: "node railway=rail";
	assertNoMatch: "way railway=rail";
	assertNoMatch: "area railway=rail";
	assertNoMatch: "way railway=rail workrules=DE:EBO";
}

/* workrules=ESBO is deprecated, should be changed to workrules=DE:ESBO */
way[railway][workrules=ESBO]
{
	throwError: "workrules=ESBO is deprecated, change to workrules=DE:ESBO";
	assertMatch: "way railway=rail workrules=ESBO";
	assertNoMatch: "node railway=rail";
	assertNoMatch: "way railway=rail";
	assertNoMatch: "area railway=rail";
	assertNoMatch: "way railway=rail workrules=DE:ESBO";
}

/* workrules=BOStrab is deprecated, should be changed to workrules=DE:BOStrab */
way[railway][workrules=BOStrab]
{
	throwError: "workrules=BOStrab is deprecated, change to workrules=DE:BOStrab";
	assertMatch: "way railway=rail workrules=BOStrab";
	assertNoMatch: "node railway=rail";
	assertNoMatch: "way railway=rail";
	assertNoMatch: "area railway=rail";
	assertNoMatch: "way railway=rail workrules=DE:BOStrab";
}

/* workrules=BOA is deprecated, should be replaced by an adequate value */
way[railway][workrules=BOA]
{
	throwError: "workrules=BOA is deprecated, replace by an adequate value";
	assertMatch: "way railway=rail workrules=BOA";
	assertNoMatch: "node railway=rail";
	assertNoMatch: "way railway=rail";
	assertNoMatch: "area railway=rail";
	assertNoMatch: "way railway=rail workrules=DE:BOStrab";
}

/* operator is not necessary for signals if equal to track operator */
node[railway=signal][operator]
{
	throwWarning: "operator is not necessary for signals if equal to track operator";
	assertMatch: "node railway=signal operator=DB";
	assertNoMatch: "node railway=signal";
	assertNoMatch: "way railway=rail operator=DB";
}

/* operator is not necessary for milestones if equal to track operator */
node[railway=milestone][operator]
{
	throwWarning: "operator is not necessary for milestones if equal to track operator";
	assertMatch: "node railway=milestone operator=DB";
	assertNoMatch: "node railway=milestone";
	assertNoMatch: "way railway=rail operator=DB";
}

/* supervised=* is deprecated, replace it with the new crossing:supervision=* */
node[railway=level_crossing][supervised], node[railway=crossing][supervised]
{
	throwWarning: "supervised=* is deprecated, replace it with the new crossing:supervision=*";
	assertMatch: "node railway=level_crossing supervised=yes";
	assertNoMatch: "node railway=level_crossing";
}

/* must have railway=signal if railway:signal:* is given */
node[/^railway:signal:/][railway!=signal]
{
	throwWarning: "signal specification given but node is not tagged as signal";
	assertMatch: "node railway:signal:direction=forward";
	assertMatch: "node railway:signal:position=right railway=level_crossing";
	assertNoMatch: "node railway:signal:position=right railway=signal";
	assertNoMatch: "node railway=signal railway:signal:direction=forward";
	fixAdd: "railway=signal";
}

/* track numbers inside a station should be railway:track_ref, not name */
way[railway][name=~/^[0-9]+[a-z]*.*/]
{
	throwError: "track numbers inside a station should be railway:track_ref, not name";
	assertMatch: "way railway=rail name=4";
	assertMatch: "way railway=rail name=4a";
	assertMatch: "way railway=light_rail name=14";
	assertMatch: "way railway=rail name=14b";
	fixChangeKey: "name=>railway:track_ref";
}
